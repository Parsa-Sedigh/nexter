@charset "UTF-8";
/* Global reset: */
*, *::before, *::after {
  margin: 0;
  padding: 0;
  box-sizing: inherit;
  /* We're gonna inherit that from the html element. */ }

/* In html element css rules, we set our overall font-size. In this case, with that, 1rem equals exactly 10px.
16px is the browser default.*/
html {
  box-sizing: border-box;
  font-size: 62.5%; }

/* Global font-settings on the body element:
We choose gold color for our brand as our primary color, because it's luxury homes then the secondary-color is a very dark blue which
plays very well with that gold color and then we have the lighter greys and also the darker grey colors as always but in darker greys,
we have a color which is also like brown a little, because that compliments the primary color in a bit better than if you would just have used
a pure black-based gray for $color-grey-dark-2 . So you see that the $color-grey-dark-2 is close to the gray sides but ALSO in a bit in the
golden part of the color spectrum.

We are ABLE to use 300 as font-weight because that's what we included from the google font. Because for Nunito which is the $font-primary, we
included 300 and 300i(italic) from google fonts.
We use josephine sans for titles and the nunito font for overall font-family because it's a bit more neutral.*/
body {
  font-family: "Nunito", sans-serif;
  color: #6D5D4B;
  font-weight: 300;
  line-height: 1.6; }

/* Let's see how many rows we want? The first row is the header and the realtors which is next to each other inside one row and the height of
this row is actually a percentage of the viewport height. So if you decrease the height of viewport, then you will see that the height of the
container(first row???) adapts as well. So the size of that first row is in viewport height units. So the first row track should have height of
80vh. So right now, we have an explicit grid with only one row and all the other items will be added in the implicit grid, so the items
that don't have any space in this one by one grid(grid-template-rows and the actual rows, have a one by one relationship right?). So right now
we only defined one row*.
Now let's go define the second row which is the features section. Now how do we want that row to be sized?
Well we simply want it to contain the content! and if we increase this content, we of course want that row to grow with that content.
That means, if we decrease the width of the viewport, the content will be go to the next lines, right, so the HEIGHT of the content would
grow. So we also want the row to grow it's height with it's content.
So when we decrease the viewport width, the content would grow so we want the row to grow with it. So how we do that?
We want that row to have min-content for it's height(yes height, because we're specifying the grid-template-rows which is for HEIGHT of rows)
In this case, we could also use auto for that row(instead of min-content) and auto is actually the DEFAULT. So if you don't specify anything,
it would be auto,Important: so auto also means that it adapts to the content(just like min-content) and in this case(our second row),
it really is the same. So we can write min-content or auto for the second row. Because either way, it's gonna mean that there will be
enough space to FIT all the content. Currently, if you say min-content or auto, that's not gonna change anything, because right now,
the content of the second row is just a little text. So the row won't grow to fit equal to it's content, actually it does, because that little text
also gets some space right? So the row will grow to fit it's content.
Important: The row is associated with height and columns are associated with width.

Let's go to third row and this row is actually not a function of the viewport height, but the viewport width. So if we decrease the viewport
width, the size of that row is adapting to the viewport and that means we're using the viewport width unit. (40vw means 40% of viewport width)
and so as you're seeing how crucial it is to think about responsiveness, right from the beginning of defining our grid tracks and columns(row
tracks and column tracks). So we don't use px, but we're using the units that make sense for the content that we're putting in that track and
units like vh or vw are crucial units to use in a real word scenario.
In exercies we usually did use some fixed size for columns and rows, but in real world, we don't always do that, so we use units like vh and
vw and we also want the rows to adapt to the content by using min-content(especially in the rows we use this min-content keyword and not so much
in the columns). So in the rows, it's sometimes useful to LET them(why let them? Because with that, they will ADAPT themselves to height of they're
content) have the height of the content.

Next row, we also want it to have the height of it's content, so use min-content and in gallery(the row that have the gallery section),
we also want it to have the height of all of those images(which are it's content) together and the same thing for footer.
So we're not gonna define any static value for the height of rows.

Yes we used a width related unit(vw) for height of one of the rows, but even with that, it means that row will have a HEIGHT(and not width) of 40%
of the viewport's width and if the width of viewport decreases, the height of that row also decreases.

Instead of repeating multiple min-content here, we used repeat().

You can also imagine that we put fixed pixel values in grid-template-rows and imagine what would happen if we then started to resize our window.
So if the users viewed the page from a phone or from a tablet. By doing that, we of course should used media queries to adapt in that situation.
But it's better to think responsive right from the beginning and size the rows and columns in a responsive and flexible way right from the start.

Now we need to define our column tracks and that's more complex than defining our row tracks. Let's leave it to next lecuture as well with the
PLACEMENT of all our grid-item in the correct position.*/
.container {
  display: grid;
  grid-template-rows: 80vh min-content 40vw repeat(3, min-content);
  grid-template-columns: [sidebar-start] 8rem [sidebar-end full-start] minmax(6rem, 1fr) [center-start] repeat(8, [col-start] minmax(min-content, 14rem) [col-end]) [center-end] minmax(6rem, 1fr) [full-end]; }

.heading-1, .heading-2, .heading-3, .heading-4 {
  font-family: "Josefin Sans", sans-serif;
  font-weight: 400; }

.heading-2 {
  font-size: 4rem;
  font-style: italic;
  line-height: 1; }
  .heading-2--light {
    color: #f9f7f6; }
  .heading-2--dark {
    color: #54483A; }

.heading-3 {
  font-size: 1.6rem;
  color: #c69963;
  text-transform: uppercase; }

.heading-4 {
  font-size: 1.9rem; }
  .heading-4--light {
    color: #f9f7f6; }
  .heading-4--dark {
    color: #54483A; }

.btn {
  background-color: #c69963;
  color: #fff;
  border: none;
  border-radius: 0;
  font-family: "Josefin Sans", sans-serif;
  font-size: 1.5rem;
  text-transform: uppercase;
  padding: 1.8rem 3rem;
  cursor: pointer;
  transition: all .2s; }
  .btn:hover {
    background-color: #B28451; }

.mb-sm {
  margin-bottom: 2rem; }

.mb-md {
  margin-bottom: 3rem; }

.mb-lg {
  margin-bottom: 4rem; }

.mb-hg {
  margin-bottom: 8rem; }

.sidebar {
  background-color: #c69963;
  grid-column: sidebar-start / sidebar-end;
  grid-row: 1 / -1; }

.header {
  background-color: #54483A;
  grid-column: full-start / col-end 6; }

.realtors {
  background-color: #101d2c;
  grid-column: col-start 7 / full-end; }

.features {
  grid-column: center-start / center-end;
  margin: 15rem 0;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(25rem, 1fr));
  grid-gap: 6rem;
  align-items: start; }

.feature {
  display: grid;
  grid-template-columns: min-content 1fr;
  grid-row-gap: 1.5rem;
  grid-column-gap: 2.5rem; }
  .feature__icon {
    fill: #c69963;
    width: 4.5rem;
    height: 4.5rem;
    grid-row: 1 / span 2;
    transform: translateY(-1rem); }
  .feature__text {
    font-size: 1.7rem; }

.story__pictures {
  background-color: #c69963;
  grid-column: full-start / col-end 4; }

.story__content {
  background-color: #f9f7f6;
  grid-column: col-start 5 / full-end;
  /* This is not flexible when we decrease the width of viewport:
    padding: 6rem 12rem;

    This is good:*/
  padding: 6rem 8vw;
  /* solution 1 for centering the elements inside this class:
    display: flex;
    flex-direction: column;
    justify-content: center;

     because of <button> was ranging all the way from left to right, we set this prop:
    align-items: flex-start;
    */
  display: grid;
  align-content: center;
  justify-items: start; }

.story__text {
  font-size: 1.5rem;
  font-style: italic;
  margin-bottom: 4rem; }

.homes {
  background-color: #101d2c;
  grid-column: center-start / center-end; }

.gallery {
  background-color: #54483A;
  grid-column: full-start / full-end; }

.footer {
  background-color: #101d2c;
  grid-column: full-start / full-end; }

/* 1. section intro
CSS grid layout module or in short, css grids.

2. Why css grid, a whole new mindset
A whole new mindset:
What are css grids?
-CSS grid layout is a brand new module that brings a two-dimensional grid system to CSS for the first time. The grids changes
 everything, like: how we think about layout, how we write our css and even how we write our markup in html.
-Css grids replaces float layouts, using less and more readable and logical css and html.
-Css grids works perfectly together with flexbox, which the flexbox is best to handle ONE-dimensional components and layouts.
-Css grids completely changes the way that we envision and build two-dimensional layouts.

CSS grid terminology:
        Css grids                                   flexbox                                         normal css
                                            (default axis with flex-direction: row)
        |-----------------> row axis                  ----------------> main axis                   ------------> x
        |                                             |                                             |
        |                                             |                                             |
        |                                             |                                             |
        |                                             |                                             |
    column axis                                   cross axis                                        y

display: grid;
(display: inline-grid;)
Just like we have a flex container in flexbox, in css grids, we have a grid container and we create a new grid container,
by setting the display prop of an element to grid. Then ALL of the DIRECT children of that grid container become the grid items.
The axes in grids are ALWAYS THE SAME and you CAN'T change where they are like what we do in flexbox.

The vertical and horizontal lines that divide up the grid and separate the columns and rows, are called the grid lines and they are
automatically numbered for the columns, as well as for the rows and those grid lines start from one, all the way to the number of rows plus
one and the number of columns of course. So if you have 3 columns and 2 rows, then you would have 4 grid lines vertically and 3 grid lines
horizontally.

The actual space that is between the rows and columns is called the gutter and the row gutter can be different from the column gutter.
What are the grid rows and columns actually?
Important: Well, the space(without the gutter) between two grid lines is called a track, no matter if it's vertical or horizontal. If it's horizontal,
 then it's called a row of course! and if it's(the track) vertical, then it's called a column.

The area between two vertical and two horizontal grid lines is called a grid line and if that area is between two adjacent grid lines and
two adjacent column lines, then that area is just called a grid cell.

Css grids property overview:
GRID CONTAINER:
1)
grid-template-rows      |
grid-template-columns   |   grid-template
grid-template-areas     |

2)
grid-row-gap            |
grid-column-gap         |   grid-gap
                        |

3)
align-items
justify-content
align-content

4)
grid-auto-rows
grid-auto-columns
grid-auto-flow

GRID ITEM:
1)
grid-row-start          |
grid-row-end            |   grid-row: <grid-row-start> / <grid-row-end>     |
                        |                                                   |
                                                                            |  grid-area:
grid-column-start       |                                                   |  <grid-row-start> / <grid-column-start> / <grid-row-end> / <grid-column-end>
grid-column-end         |   grid-column                                     |
                        |                                                   |

2)
justify-self
align-self

3)
order

3. Quick setup for this section

4. Creating our first grid:
In .container>.item.item--1*6 emmet code, the *6 part will replicate the .tem.item--1 part of emmet code, 6 times. So with that emmet,
we would have one <div> with class of container and 6 div with classes of item and item--1 in there. Now the problem with that is, each
of those 6 items will have the number 1.
Learn: But in emmet we can use $ and that $ will get replaced with the current number.

When you make an element, a grid container, nothing really changes(in opposite of display: flex; which makes the children of that container,
sit next to each other in main axis). That's because we didn't define any columns or rows.
By using grid-template-rows, we can define our rows. So let's say we want our six elements that we have currently, to be divided in 2 rows and
3 columns(so 2*3=6). So we want 2 rows and 3 columns and in grid-template-rows we define our 2 rows and we want the first row to be 150px and
the second one also 150px. So grid-template-rows: 150px 150px;

So in grid-template-rows, we define the height of our rows. Now let's do the same thing for columns. So use grid-template-columns.
So now our elements inside that grid-container, have 150px width and 150px height.
After those two props, we say our elements are now already laid out as a grid.

In firefox, after clicking on the grid icon on grid container, you can go to layout tab to see it better.

In grid, column LINES(yes the line ITSELF and not the area that it makes with row lines) and row lines, get automatically numbered and in
layout tab of firefox, you can turn on the display line numbers on the grid container. Remember, if you set some gaps for lines, the INNER(because
the first and last line numbers, well, they can't have gap right??? Because those outer ones are the bounderies of grid layout)
lines can have some space, so they're not a thin line number anymore.

We can also have space BETWEEN the grid items(the children of a grid container) and that space is called gutter which can be defined for
columns and rows and we can define it by using grid-row-gap(for rows). This prop is defined on grid CONTAINER.

If you want the same gap for columns and rows, instead of writing both grid-row-gap and grid-column-gap, you can use grid-gap.

So you make those 6 elements in a grid layout. If you wanted to do it without grid, we would have to have just a wrapper for
the upper 3 items and a wrapper for second 3 items. */
/* 5. Getting familiar with fr unit:
We can do better when we're defining our rows and columns one by one in grid-template-rows and grid-column-rows. So imagine we had 5 rows
and each of them width height of 150px, it wouldn't be good them to define all of them one by one. That's why in css grid, we have a new
function called repeat() and inside of () of it, we specify the number of rows and columns(depending on we're using repeat() in grid-template-rows
or grid-template-columns) that we want and then specify the height(if you're specifying rows) for all of them(of course we use repeat(), when
the height(for rows) or width(for columns) of all of them are equal.).
Important: When you say: repeat(2, 150px); you're creating 2 tracks and if it was used in grid-template-rows, you're creating 2 tracks for rows.
Ex) grid-template-rows: repeat(2, 150px); means 2 rows with height of 150px and it's equal to have: 150px 150px

Ex) Let's imagine currently we have grid-template-columns: repeat(3, 150px); but now we want the third column to have 300px and not 150px.
What we do now?
grid-template-columns: repeat(2, 150px) 300px;

What if we wanted to make the last column occupy the rest of the grid container?
This can be done in flexbox by using flex: 1; and with that, the flex item would expand and occupy all the possible space. In grid we haven't a
prop like that, but we have a similar functionality. In this case and in grid, we need to use fractional unit.
Important: So you can use 1fr for the width of column you want it to occupy the rest of the grid container in the grid-template-columns prop.
Learn: 1fr is a fraction of the available space.
Recap: When you have grid-template-columns: repeat(2, 150px) 1fr; , we define 3 column tracks. The first one will have 150px, the second one also
150px and the last one is 1 fractional unit and the fr represents a fraction of the available space. So it takes all of that space, when we set it
to 1fr.

Also there's other way of using fr unit. When you say: grid-template-columns: repeat(3, 1fr); with this, we have 3 tracks each of them with 1fr and
by saying that, each of those three column tracks has the same width(because we used repeat() for them) and by using 1fr for all of the
tracks, we can divide the entire space in 3 parts.
So in grid-template-columns: repeat(3, 1fr); we have 3 columns, all with the same width.

Ex: grid-template-columns: 1fr 2fr 1fr; with this, the second column is double the size of the first column and last one. Why is that?
Because 2 is double of 1. So because we're using fr, all the empty space is divided and then 2 of the fractions are assigned to the second column and
then 1 fraction of empty space if assigned to first one and 1fr is assigned to last one.

Ex) When we say grid-template-columns: 1fr 3fr 1fr; , the available(because we're using fr) space is divided into 5 parts(1 + 3 + 1 = 5).
EX) When we say grid-template-columns: 1fr 3fr 3fr; the second and last one are three times bigger than the first one.
Ex) In grid-template-columns: 50% 1fr 1fr; let's imagine the grid container has 1000px width, then the first column has 500px. So what we
realize is, the percentage unit doesn't take the gap into account. So basically it takes 50% of the entire width of grid container and then the
rest is for other columns and also for the gap. So if you make it to have 80%, you see the column with fr units become narrower. Because now
the first column becomes larger and the gaps are still the same(because we didn't change the gaps between columns), therefore the columns with
fr units become narrower.

Ex) In grid-template-rows: repeat(2, 1fr); and by having the grid container with 1000px height(why I say height here? Because rows are in relation to
HEIGHT of grid container and the columns are in relation to width of grid container, so when we set a number in grid-template-rows, it's in
relation to height of the grid container and when we set some numbers in grid-template-columns, they're in relation to WIDTH of their grid container.)
now each of the rows occupies all the space it can, in order to fill up the height of the container. So the entire height of container is
the gap between rows and the height of rows. So we have 2 rows with the same height and they're occupying the entire height of their container.

We used fr unit, more on the columns than rows.

Now let's place the grid items exactly where we want them to be on the grid. Because currently, all of those items are automatically placed
in the order which we have them in the html source code. But we can change that.

6. Positioning grid items:
When you want to position items, remember to turn on the line numbers in firefox devtools.
Right now, all of our grid items are laid out according to their html source code order and if you see the result, the reason for positioning of
those grid items is for css grid's automatic placement algorithm and the default behavior is that the items are laid out just like they are in the
html code.

Learn: A grid cell is the area between two adjacent row and column lines. In the codepen, the grid cell number 5 is the area between column line 2 and
 column line 3 and the row line 2 and row line 3.

Currently we want to put item number 1 in the place where item 5 sits. How we can do that?
That's when the line and row numbers come into play!
First let's go to the item1 and define a couple of props. First we define grid-row-start and set it to 2 for that item.
Learn: In grid-row-start we specify the number of row line which in that row line we want the cell to start.
Right now, we want to put cell 1: Orange in cell 5: Blue and as you can see, the cell 5: Blue, starts at row line number2, so for placing that'
1: Orange in there, we specify it's grid-row-start to 2 and with that, the item which has that prop(in this case, the 1: Orange), moves to the
second row.
Important: So with grid-row-start: x; the item that has that prop with x value, starts from xth row.

After that, we set grid-row-end to 3 for that item--1 so with that, we wrote a cleaner solution(although without specifying that, we get our
desired result in that case.)
Important: So by saying grid-row-start: 2; and grid-row-end: 3; , we say that grid item which we define these props for that, should be placed in
 a cell which that cell starts by row line number2 and ends at row line number3.
So now, the item--1, moved to the second row(because of grid-row-start: 2;) and then the other item which before was placed in the cell which NOW,
the item--1 is sitting there, move up in the place where item--1 was sat there before. In other words, their cell was swapped.

Now we need to kinda shift the cell-1 in column axis to place it where currently cell-5 sits. So let's use grid-column-start and set it to
2 and then for cleaner solution, set grid-column-end: 3; so now with that, we've placed our item exactly in the grid cell we wanted.

Also there's a bit easier way to do that and instead of grid-row-start and grid-row-end we can say: grid-row: 2 / 3;
So grid-row is shorthand for grid-row-start and grid-row-end.

Now let's position 5: Blue instead of 4: Pink . So let's go where we select the number 5 cell and then specify grid-row and grid-column for it.
Now what about values?
Currently the 5: Blue cell is in the second row or in other words, between row line 2 and 3 but we want it to be between row lines of
1 and 2. So grid-row: 1 / 2; Important: now with that, it moves to first row. Because the grid-row-start is set to 1, so it goes to first row.

Also instead of saying grid-row: ...; and grid-column: ...; there's a shorthand for it which is grid-area.
Also there are actually more ways of positioning items in grid.

We placed 6: Brown cell in where currently 3: Violet lives. So let's go to 6: Brown and say: grid-row: ...; and grid-column: ...;
After doing that, there's no gurantee that those items will SWAP in where in the past, the other one lives. So if 6: Brown goes to where
3: violet; lives currently, there's no gurantee that the places of them actually swap. So maybe 3: Violet goes an other place after the other cell
comes into it's place.*/
/* 7. Spanning grid items:
Let's see how span grid items across multiple grid cells in order to occupy entire areas. So items can occupy multiple cells and by default,
each item in the beginning occupy 1 cell.
So suppose we want that violet item not only to occupy that single cell, but to span across those 2 cells(one cell is the cell where currently
is there and the other one is the current 1:orange cell.) How we do that?
So far we only placed grid items into single cells and therefore the end is always the beginning + 1.
Important: So when an item has just one cell we can say: end of item(not cell!) = beginning of item + 1 and the end and beginning means the
 grid-row-end or grid-column-end and beginning means grid-row-start and grid-row-start. In other words, when an grid item has 1 cell(which by
 default is), the grid-row-end = grid-row-start + 1 and that's true also for column. Therefore so far, we always had grid-row: <x> / <x+1> or <x+1>/x
 and also that's true for column. So only one column and one row which that one column and one row result in one cell which we had so far.
But what if we put a higher number?
If we do that, the element would simply occupy more space(more cells and also the gap between those cells too!).
So for example let's say we want the 1: Orange to start at column num2 and end at column num4.
Important: So when a grid item occupies more than 1 cell, yes! it actually maybe occupies 2 or 3 or ... cells, but also the gap between those
 cells.

Now what about the grid item that was in that cell which now belongs to 1: Orange grid item?
Well, it simply moved down. Because that's what the css grid algorithm does. So if we have more items than the number of cells in a row(or
when we end up with more items than the available space, so the available space isn't enough for our items), then css grid will automatically
add a new row or a new column. But in this case, just a new row and that new added part(in this case a new row), called an implicit grid.

Now if you make 3: violet to span 2 cells, it will go down, to a new line and also 4: pink will do the same. WHY?
Because we also placed another element (1: Orange) in where the other element which is now explicitely positioned. But we want to also
EXPLICITELY place the other element in where another EXPLICITELY positioned element exists! But that doesn't work and therefore the new
explicitely positioned element goes to find a new place. But if you really want to make the other one to be in that place and not the other
element which currently is in that place, we need to explicitly set the row number(or the column number. But when use which? If you CURRENTLY
set column and you don't get the desired result, you need to explicitly set the row(start and end) number for the item that you want to
place it where another item currently sits there, but if you set row and didn't get the desired result, you need to explicitly set the
column-start and end number for that item) for the element we want to be in that place which currently another element lives in that place.
Now if you do that and explicitly set the row-start and row-end(which means it was positioned with column props but we didn't get the
desired result by just specifying the column props for that element) for the element that you want to position it in where the other
explicitly positioned element currently sits there, you see that the other one which was before in that place, goes under the new one(the one
we set both column and row props to position it exactly where we want).
So what that means, is we can actually have multiple grid items in the SAME CELL(or cellS, if the item was expanded).

So maybe one EXPLICITLY POSITIONED item which expanded to 2 cells gets on top of another POSITIONED item which just has 1 cell, like our
code in codepen.

Now if you want the other one which currently is under another positioned element, to be on top of the other one, you can give it a higher z-index.

So that was one way of spanning items across multiple cells. But there's another way. So let's do that with the 2: green item and currently
it's not positioned at all and that's perfect to show how it works. Now we want it to be from column1 to column3. So we could say:
grid-column: 1/3; and after that, because we have another positioned item(if it was not positioned, there was no problem and actually this item
would go down, instead of our current item that we want to position it) in the place where we want it goes to the last line in our grid layout
inside the grid-container, so we need to ALSO explicitly set it's row props(start and end).

So instead of that, we can say we want it to span across 2. So: grid-column: 1 / span 2; instead of grid-column: 1 / 3;
Learn: So span x; means it must span across x cells. For example, grid-column: 2 / span 2; means the grid item must start at column num2 and
 span across 2 other cells in the column direction(because we're using column prop).

if you used span y and you see that it creates a new column or row, that's because for example you defined 3 columns and with that span 2,
you go one column further which it wasn't defined and that new column is completely empty, because we didn't define any width for it, but it
still tried to kinda create a new column there. So if you're not really sure what to put in the span <y>, there's actually even another way for
spanning items over multiple cells.

This approach is for when you don't remember how many columns(in this case) we have. All we know is that we want that grid to be ALL UNTIL THE
END and in order to represent the end, all we have to do is to say: -1. So when you want an item go till the end, instead of hard coding
how many cells we want to occupy by using the span <x> approach, we simply put -1 and then it goes all the way till the end.

In example below, we say the item should start from column number2 and go all the way to the end.
grid-column: 2 / -1

So for spanning items we use 3 ways(which in all the ways, we use grid-row or grid-column depending on you want to span the item in row direction or
column direction):
Actually there's 2 way and the third way is for special use case.
1) We define the END(because we want to span the item right?) number of the row or column line.
2) Use span keyword which actually is better than the first approach
3) (IF you want to span the item all the way till the end of grid) use -1.*/
/* 8. Grid challenge:
The right sidebar, is slightly more narrow than those 3 columns next to it. So we need to define the width of the sidebar column and then
divide the remaining space for the other columns or the other tracks and the header and main content and footer, we'll also have some spanning
going on(because they have multiple cells).

Also we have the SAME gutter for rows and columns.

9. Grid Challenge A Basic Solution:
Learn: For selecting all the DIRECT children of an element(the container of those elements) at the same time, we say:
 <select that element which is direct container of the elements that we want to apply styles to all those direct children> {
  & > * {
   }
 }

First define display: grid; on the .challenge to make it a grid container.
In the challenge, we have 4 columns, 1 column for each of the small boxes and then 1 column on the side, for the sidebar and also
we have 4 rows. So let's define grid-template-rows: 100px 200px 400px 100px;
So the header row, has 100px height.

When defining the columns inside .challenge, remember that the sidebar was a bit smaller than the rest of the columns and what we want, is to have
three equally sized columns and then one smaller one. So say:
grid-template-columns: repeat(3, 1fr) 200px; .
So sidebar will have 200px width(because we're defining the columns) and then, the REST of the space will be divided for the three other columns and ALSO the
gutter.

With those definitions, we have 4 column tracks and 4 row tracks as well.
Currently we have 7 grid items, but we don't see the rest of the rows and the column tracks(currently we just see 2 rows and all our columns which are 4 columns) and
therfore, only the first 2 rows of our defined grid-system is currently filled with items and that's because we haven't enough items to fill all of the rows. But
that's not a bug or an error from us, the developer! It's intended. Because we want to actually give 2 rows to 2 grid-items(header and footer), so by doing that, all
of the rows will be filled.
Important: So in the beginning, if you don't have enough items or actually plan to don't having enough items, all of the rows or columns might don't get filled and
 in 90% of situations, that's intended, because we want to give for example the whole of a row or a column to just 1 item or 2 items and... and therefore, at the END,
 definitely all of the rows and columns will be filled(or maybe the unfulfillment of some rows or columns are actually intended by developers!).

So currently we see those empty grid-cells which were actually created with our grid track declaration. We just don't have enough grid items to fill all of those
cells. But don't worry, we're gonna care about that now! So let's start by POSITIONING all our grid items.

First thing to do, is to make the header <div>, span all the way from the first column line to the last one. So select that grid-item and say:
grid-column: 1 / -1

Important: The trick for go ALL THE WAY to the end of the grid-system:
 1) Use span <number of columns or grid to go to the END of grid-system>
 2) use -1

Now with just making an item or some items to span all the way to end of grid-system, that possibly will make the other items to go downward and fill the remaining and
empty rows and that will make our kind of problem to nearly be solved.

After making the header go all the way from left to right, notice we didn't actually have to declare the grid-row property there. Because the automatic placement
algorithm, takes care of putting the header right in the first line, because it's actually the first element in the markup as well. So that's automatically placed there
and we don't have to declare the row props too! and the same actually applies to our small boxes. Because they're already exactly where they should be, so we
don't have to do anything. Because again, automatic placement outs them, where we want them to be.

The sidebar should spans across those 2 cells starting from row number2. So select the sidebar first. After setting the grid-column or sidebar, it's position is
not still correct, because we want it to start from row number2. So let's set grid-row for it explicitely(so we had to define BOTH column and row props for it,
in order to set it exactly where we want it to be).


Now we must make the main-content <div>, spans 3 cells from column1. So select main-content <div> and all we have to set for it, is the column prop. Because the row
prop for it, is already correct(it's already in the correct row and therefore, all we have to do is to manipulate its position in the column prop).

That layout is hard to build in old-school fluid layout.
There are basically 2 more ways to position grid-items on the grid.*/
/* 10. Naming Grid Lines:
Let's look how we can position grid items on the grid, by naming our grid lines. Before this lesson, we looked at how to position grid items on the grid,
by using the automatically generated grid line numbers. But we can make our lives easier by NAMING those grid lines.
So method 1 is line numbers. Now let's comment out all of the code that we wrote for the challenge which we wrote with method 1 of positioning.
So let's start from scratch. Now copy the code you had before and paste it for method2.
Learn: For naming our grid lines, we can use: [<name of the line>] . So when we're defining our grid lines(so inside grid container or the element or selector that has
 display: grid;), therefore, when we're saying like: grid-template-rows: ... or grid-template-columns: ... or when we're actually DEFINING our lines(whether column lines or
 row lines), we can give each of them a name, before specifying their value.
 Also remember: When you have specified n values as rows of a grid container, you would have n + 1 line numbers for rows and 2 of those line numbers would be
 edge numbers.
The best practice for naming grid lines is to describe the content that will be IN the track. So in our example, we wanna name the content between line number 1 and
2 and because the content inside those 2 line numbers, is our header, I named the track, header and after doing that, say whether it's the start or the end.
Learn: So the naming of grid lines is based on 2 factors:
 1) The content that would go inside that line number(the one we're CURRENTLY naming it) and the next line number.
    So in this case, the content that would go between (line number 1 WHICH HAS 0 HEIGHT! BECAUSE IT'S AN EDGE LINE NUMBER!!!) and 200px(line number 2) is our header.
 2) Is the current line number, the beginning or the end of that content? If it's the beginning, give it -start at the end of it's name and if it's end, give it: -end.
 In this case, we gave the first line number(which isn't explicitely set, because it's an edge line), the name of header-start and the next line number, header-end(which is
 the line number after traveling 100px).
EX)
grid-template-rows: [header-start] 100px [header-end] 200px 400px 100px;

So now, the line number1, which is an edge line, is no longer JUST called line number 1, but it's ALSO called: header-start and the second line, is called header-end.
NOW WAIT!!!
What about those small boxes there?
We named the line that is the beginning of those boxes, header-start, but this name doesn't fit the content that we have(those boxes)! So what we do now?
The second line is the header-end, but simentinously, the start of those small boxes!!! In other words, it doesn't make sense that that line there, is called header-end,
because it's not JUST the end of the header, but ALSO the start of those small boxes and so for that reason, we can actually give a line, more that one name.
So those are arbitrary names that we come up with(at least the first parts of the names are arbitrary!- for example, box name is arbitrary) and then we just
call the line, before the boxes, start, and the line after the boxes, end.
So the second line number(which is the line, in between the header and the boxes), is now  only called header-end and also, at the same time, is called box-start.

It's a good practice to name line numbers and then use those names, to position the grid-items in it and we're gonna do the same thing for column tracks, because remember:
Important: In a grid-system, we have 2 kind of lines(tracks === lines): row-lines and column-lines .

For USING those names, instead of using the numbers of lines, we just use their names. Also instead of using span 2 or -1 for spanning the grid-items, we can use
the name of lines that those grid-items. ends.

In our example in codepen, footer class, doesn't use(need) the row declaration(grid-row prop), so we can't use row line names for it. So in fact,
we wouldn't maybe really have needed to define all of those names for row lines!

In column tracks(lines), we have a different situation. Because when we were defining the column tracks for our grid-system, we had that repeat() function there,
which is gonna create three column tracks there with ONLY that 1 defenintion(with only using a function). So we haven't multiple values for column lines,
so that we can name EACH of them separately.

Remember: Therefore, it wouldn't make much sense to put the line name before the repeat() function and then after it. Because by doing that, ONLY the
lines before those 3 lines which are created by repeat, and after those 3, would get a name. But we want ALL of the lines to have a name. So what can we do?
Well, we put the name into the () of repeat() ! and in this case, we're gonna call those 3 lines which are created by repeat() , col-start and also col-end(why?
again, because one line, is the end of previous column and also the start of next column, so we give it two names.).
In the example, it will create a so-called: named set of grid lines.
So with that(repeat() function with having 2 names), we create 3 columns and each of them starts with a line called col-start and one with col-end and that
would mean, that we would have CONFILICTING line names. RIGHT?
And so what happens, is that for the first column, it's gonna be called: `col-start 1` and `col-end 1`, then for the second
column track it's gonna be called col-start 2 and col-end 2 and ... .
Important: So: repeat(3, [col-start] 1fr [col-end]) is a named set of grid lines. So when we have line names inside repeat(),
 then it's gonna create a named set of grid lines.
So for example, in our example, in the .header , the first COLUMN grid line is called col-start 1, because the header, is starting from the
first column grid-line which is col-start 1. So the first grid column line of our grid layout(why all of the grid layout? Because the
vertical lines spans all over the grid system right?) is col-start 1 and the next grid column line is called col-end 1 and AT THE SAME TIME, it's
also called col-start 2 and the next vertical one is col-end 2 and col-start 3 and the -1 as the grid column lines is called grid-end which is
the name that we choose when we were defining our column names.
So in .header , write:  grid-column: col-start 1 / grid-end;
Now we could still use the -1 trick instead of grid-end , to indicate that the grid-item should go all over to the end, like we had before.
Now let's change the gird number columns of .sidebar to grid-name columns.
Important: When you have grid-column , you can use named column grid lines and when you have grid-row prop, you can use grid row line names.

EX)
repeat(3, [col-start] 1fr [col-end])

So in professional layouts, we name all our tracks, both the row tracks and the column tracks and then USE these names to position our
grid -items to build our layouts.
In the next lecture we're gonna see the third method of how to position grid-items.*/
/* 11. Naming Grid Areas:
The third method of positioning grid-items on the grid, is by naming entire areas. First comment out the method 2 codes in codepen and copy it and
paste it to start using method 3.
Now how we do that?
We use grid-template-areas prop. This is how we name grid areas:
We write a couple of strings and in there, we basically give each grid cell, a name. So in our case, we have a 4 by 4 grid(4 x 4 grid).
So in the first string, we give the first 4 grid cells, 4 names and what are our first 4 cells?
Well, those are the 4 cells inside header and all of them, are for the header. So let's call each of them, head. So: "head head head head"!
So the 4 cells will be called head and that's because we want the header, to be in all of those 4 cells. So basically that first string here, defines
the first ROW of our grid. Now we hit enter, then come to the exact place under the last string you defined for defining the next string and then
we need to call the next 4 cells (which are in a row, so the three small boxes and the most up cell of sidebar). So let's call the 3 boxes, box and
then the last one(most up grid cell of sidebar), side.
So it's good to use really small names, so as small as possible, so that it doesn't take too much space in the declaration of names of lines, so
that it's also not too hard to write, because there's usually a lot of repetition(in this method). So: "box box box side".

So basically, this template area approach, just creates a representation with text, of how our final layout is gonna look like.
Now what do we have in the third ROW?
We have 3 cells of main-content , so let's give each of them "main" name, so: "main main main" and then on the side, we have one of the cells of
our sidebar. So "side", therefore for the third row we have: "main main main side" and then in the last row and therefore, it's the last string,
we have 4 times, the footer. So let's simply use foot for the name of each of those cells in there. So : "foot foot foot foot"

Important: In third method(naming grid areas), each row is a string.
This is a great way of placing grid-items on the grid, because it's simple.
Now once you have the declaration of cells finished(once the string declarations finished), then all we have to do is to actually PLACE the items.
So let's just remove the grid-row and grid-column from the code we currently have in codepen and start fresh.
Let's position the .header. Now use grid-area prop. In the past, we used this prop to put the column-start, column-end, the row-start and row-end(so those four
numbers, remember?). BUT! There's actually another way of using this property here and that's called for the grid-template-areas(the strings) that we defined
earlier.
Now all we have to do, is write head for the grid-area prop of .header . So:
.header { grid-area: head; } without any quotes. So it places this item(head) on the entire area that we defined to be head. So imagine if we put sth else for
the first row and for the last "head", like "side", so if we had: grid-template-areas: "head head head side" and for .header, we had:
.header: { grid-area: head } therefore, Now the header, only occupies those three cells which has named "head" and for grid-area of .header ,
we used head name and the sidebar cell is at the fourth item.

Now after setting the named grid-areas for .header{} , we see that those 3 small boxes are positioned properly, so they don't need any grid-area prop.
So let's go to .sidebar{} and for that, just use grid-area prop and for it's value, all we have to do is to say the name of the area which is side and the
.sidebar is exactly where it should be!

So the third method has a completely different philosophy. So in this approach, FIRST we think about the layout(the defining of grid-template-area in the
grid container, is the process of thinking of layout). So where all of those items should be placed and then all we have to do is to give the names to
each of the classes that we have(so for example we gave the head name, to .header in order to give the .header , all of the grid-areas that have head name.)
While with the two other methods that we did before, we used the names of the lines(method 2) or the numbers of those lines(method 1), which those 2 are quite
similar, and then, for each of those items, we had to think, where to position them.

Important: When we create that template-area (grid-template-area prop in the grid container) definition, we need to be careful and create a COMPLETE
 REPRESENTATION of our grid system there.
So if it's A BIT different at all, then ALL of it is not gonna work. So for example, if you just delete the last foot name from grid-template-area in our case,
you'll see that it's not working AT ALL anymore and looks really weird and that's because, we didn't really fill up, all the 16 cells that we have in our case.
So we have 4 columns, 4 rows, when 4 * 4 makes 16 and so there, we have to have 16 names. But we deleted one of them, so it's now 15 names and that causes serious problem.

Another thing that we can do with template areas approach, is to actually leave empty cells and all we have to do for that, is to instead of deleting the name
of that cell(which would cause problem), is to put a dot. For example, if we place dot instead of fourth head cell, the small box 1 would go to the place where
that fourth head cell was placed before and other small boxes would shift one cell to the left but the sidebar cell in the second row(which is the row that
other boxes are there too, wouldn't shift to left, because we explicitely set it's position). WHY that small box 1 would go there and not other cells?
Because we didn't really(explicitely) those small boxes there. Right?
So if you REALLY(because currently in our example, by putting dot in the place of fourth head cell, that head cell is gone, BUT other grid cell or item which is
small box 1, is now in the previous place of fourth head which we deleted, so that place STILL isn't empty!) wanted to leave a cell empty, we would have to
then place those three small boxes in the place they should be always, even if there's other room in our grid system, so they won't shift at all.
For doing that, let's select those small boxes with comma selectors: So give those small boxes, some different classes:
.small-box-1, small-box-2, small-box-3 {
    grid-area: box;
}

But this isn't correct. Because now, the small-box-3 has all of the place where those 3 boxes should be exist and also the gutters are gone!
So obviously this is false and that's because, the grid-template-area definition isn't correct. Because currently, the place where this
small-box-3 is placed, in the grid-template-area , is called: box box box. So what we say in box box box, is that, that area should all
the be same, which in fact, it is not!
So let's change box box box to box-1 box-2 box-3 , so now in grid container we have:
grid-template-areas: "head head head head"
                     "box-1 box-2 box-3 side"
                     "main main main side"
                     "foot foot foot foot";

and then put box-1 for grid-area prop of box-1 and then put box-2 for grid-area prop of box-2 and ... . So:
.small-box-1 { grid-area: small-box-1; } and ... .

Now with that, all of the three small boxes are in the place where they should be and they won't shift at all and therefore, the fourth cell of
header is empty now.
That was all the content for naming grid-areas and how to position grid-items on the grid with this approach.

So these 3 methods, can be used in different situations. For example, the third method(naming grid areas by defining grid-template-areas in grid container),
is great for smaller layouts(like 4 by 4 or 5 by 5 grid layouts), but if we have a huge layout like a complete page, maybe with 12 columns or 15 columns and
10 or 15 lines, then it becomes very unpractical to write out all of those area names. It's simpler to simply name the grid LINES(approach 2) and not
grid AREAS(approach 3) and do it like the second approach. */
/* 12. Implicit Grids vs. Explicit Grids:
Let's create a new project. In Emmet, if you write: .container>.item.item--$*8 , it would create a <div> with class of container and then 8
direct child of that container, with classes of item and item-$(1, 2, ...).

You can place .item inside .container, even without & selector, so it's no problem, because the .item is actually inside of the .container. So:
Important: If an element is inside an other element, you can nest the selector of child element inside the selector of parent, but if an element isn't
 inside another one in the markup, you can't place the nested one inside the parent even if you don't use & selector.
EX)
<div class="container">
    <div class="item"></div>
</div>
<div class="outside"></div>

.container {
    .item {} // would be applied

    .outside {} // wouldn't work
}

Now let's add some grid tracks and starting with the row tracks. So define grid-template-rows in the .container .
Important: Also we want 2 columns with the exact same width, occupying the ENTIRE width of the container. So use: repeat(2, 1fr);
and just to see, what's going on there, let's add some gap with grid-gap prop.

But currently, we have 8 items in markup but in css, we defined 2 rows and 2 columns! So actually, we defined a 2 by 2 grid which are
perfectly shown, but then, down them, we have the other four cells. Why? Because we actually have 8 items.
Those four grid cells that we (explicitly) defined and they are at the top of the other 4 ones which are now occupied by those 4 grid items and
this is the so called: explicit grid. Because we EXPLICITLY defined HOW those rows and those columns should look like.
So again, that upper part(those 4 grid cells) of the grid-system is called explicit grid.
Important: Now if we have more grid items than we have space, well, then css grid, automatically adds some more tracks to the grid system, so that
 we can then fit all of those remaining grid-items and that's what happened in our example.
You see down there, those 4 items are in two ROW tracks that were added automatically. So they were added to our grid system, in order to
fit the remaining 4 grid-items and that part(those 4 items) of the grid-system, that part is called the implicit grid.

So the part that we ACTUALLY defined in our code, is the explicit grid, so the part that was defined by grid-template-rows and grid-template-columns props
and then the part that is automatically added, in order to fit the content that doesn't fit IN our explicit grid, is called implicit grid and
css adds the implicit grid after that explicit grid.

Actually, a track is the space between 2 lines.

Now what if we wanted to somehow style that implicit part of the grid?
There's a property for that. So let's say that we want the row tracks in implicit grid to have a defined height and we can do that by using
grid-auto-rows: 80px; prop. So now those automatically added tracks, they have a height of 80px. So the last 4 items have height of 80px.

Also in the grid inspector in firefox, the implicit and explicit grids look a bit different. So you see that solid line goes AROUND the EXPLICIT grid
but doesn't go around the implicit grid too. So the solid line ends where the explicit grid ends and around the implicit grid, there's no
solid line.
Also the grid lines in the explicit grid are dashed while in the implicit grid, they're dotted.

Now you may ask why are those additional grid-items that we can't fit into our explicit grid, added as rows and not as columns?
It's because of a simple small property that is called grid-auto-flow and this prop by default is set to row, but we can also set it to column,
on the grid container. So now if you set: grid-auto-flow: column; on the .container , the remaining items(the items in implicit grid) are now
no longer added as rows, but as columns. Because we told our grid(grid-container) to flow as columns.
So you also see that there's a difference in the way that those items(the grid-items in implicit grid) are placed and what this means, is that the
automatic placement algorithm now places these items in order to fill up the columns and no longer the rows.

Important: So when grid-auto-flow is set to row(the default), if we have some implicit grid-items, css will automatically create additional rows and will
 keep the NUMBER of columns the number that we explicitily defined in code. But if you set grid-auto-flow to column, the implicit grid-items will be
 added into new columns, so the NUMBER of rows will be preserve as what we defined in the css code and instead, the number of columns will be increased.
 Now with having grid-auto-flow: column; , if we added more and more grid-items, then new columns would be created and the number of rows will be preserve.
 Now of course, if we can style the rows that are automatically added(which means the grid-auto-flow is set to row) we can do the same for the new created
 columns, by using grid-auto-columns: <the width of automatically added columns>.
 So grid-auto-columns only applies as soon as we set aut-flow to column and the grid-auto-rows(if is set!) for the automatically created rows,
 is not really relevant for this case(the case where we set grid-auto-flow to column, so the grid-auto-rows won't affect anything but the
 grid-auto-columns will affect.)

So you saw, that it's actually not a problem at all, if we have more items than we explicitly defined in our code(for example if you use 3 values for
grid-template-rows and 3 values for grid-template-columns, then we would have 9 items, but if we had more than 9 items, it would create implicit rows
by default!), than we can fit them in the grid that we defined initially.
So this implicit grid and the ability to style those additional rows and columns, is great for use cases, where you don't really KNOW how many rows
or columns there will be in your grid-system or in your layout.

So for example, if you have an ajax call where you can load data from a server(api), while the page is loading and you don't really know if there
are 10 items or 12 or ..., so if you don't know how many there are, you can simply style those automatically added rows or columns and then everyting
is gonna work as you expected. So you can control how the grid will look like even if you don't know how many items there will be in it(the grid system.)*/
/* 13. Aligning Grid Items:
Now we're gonna look at different ways of aligning grid items to grid areas. Let's first set grid-auto-flow back to it's default value. So by doing that,
our grid-items are placed in rows rather than in columns(in other words the number of columns would have the number we defined in our code)
and so that the additional items are then placed in the rows.

Also let's add some spanning there to two of those grid items, so that we can better see how this alignment of grid items to grid areas work.
For that let's select item--4 and item--7 and give them different background-color and for item--4, lets say we want it to start
on the grid row number 2 and then span across three row tracks. So in other words:
.item--2 {
    grid-row: 2 / span 3;
}

and you will see that it also shifted from the second column to the first column track(gone left side) and the instructor is not really sure why it
did that!!! but it has to do with the automatic placement algorithm.
Also by using grid-column: 1 / -1; on the .item--7 , you'll see that the las t grid item goes to another newly created row track. So now we actually
have 4 implicit row grid tracks and 2 explicit grid row tracks.

Aligning the grid items to grid areas is very similar to align-items in flexbox and in fact, we have the EXACT same property in css grid too.
So just like in flexbox, we apply these props to the grid container. So give .container , align-items prop which is gonna align the items across the
column axis and if you put it to center, that's what we meant with aligning the grid ITEMs inside of  grid-AREAs.
For example in our example, the elements with orange background(and the content that are IN that grid item) are the grid items and
and that grid item is now aligned vertically in the center of the grid AREA.
In devtools, we can see the row and column tracks.

Now why the grid items were streching all the way from top of their grid-area to the bottom of their grid-area, before we set that align-items to
center?
Well, it's because of the same reason that it is in flexbox and that's because align-items by default is set to stretch. So if you set it to
stretch, then the grid items stretch across their entire grid-area(because the grid-item maybe has spanned over multiple grid cells, so it's
false to say just it will be stretch to grid-cell!). Also we can set it to end or start. For example with end, you can see that each of the grid-items
is aligned to the end or bottom of each grid areas.

We also have justify-items which we haven't in flexbox because flexbox isn't a two-dimensional layout system and in grid we set it on grid-container.

In grid, we have align-items which aligns the items across the column axis which means vertically and then we have justify-items which aligns the
grid-items across the row axis or horizontally. So by saying:
.container {
    align-items: center;
    justify-items: center;
}

The items are completely centered both horizontally and vertically inside their grid area(and if an item doesn't span across multiple cells,
it would be actually centered inside it's grid cell, because in that case, the grid cell and grid area would be the same).
So with align-items, we align grid-items vertically and with justify-items, we align them horizontally inside their grid-area.
In firefox devtools, it would show you the grid-CELLs and not grid-AREAs, you should find out the areas yourself based on your code.
Important: If we would have an grid-item that spans across multiple grid-cells, it's grid-area is the space of cells + gutters between those cells.

The default of justify-items is stretch.
if you set justify-items to start(which means: start of the grid-AREA), the grid-items would go to the left side of their grid-area.

Now, as in flexbox, where you have the align-self prop, in order to override the align-items prop that you set or may not set in the flex container,
for one individual flex-item, we have the same in the grid. So we have align-self and also justify-self.
So if for example, you set align-self prop for item--4 in our example, it will override the align-items prop which is on the grid container. So if
you set it to start for item--4, then ONLY that item will move to the top and now with that, it will vertically aligned to the top of it's grid-area.
So just like flexbox, the <>-self prop, overrides the overall setting which is set on the grid-container.
Important: BUT IN FLEXBOX WE ONLY HAVE align-self, because again, it's just a one-dimensional layout system, but in grid we have align-self and also
 justify-self for the horizontal direction alignment.
And that was how we align grid-items to grid-areas, both horizontally and vertically. Now let's look how to align entire TRACKS to the grid CONTAINER,
go to next lecture.*/
/* 14. Aligning Tracks:
Important: In the last lecture we looked how to align grid-ITEMS to grid AREAs and now let's look how to align entire grid-TRACKs to our grid-CONTAINER.
Before that, we need to make a couple of changes in our example, first add a comment above align-items and then comment out grid-template-columns,
because we no longer want columns to occupy the entire container, because then we can't see how this lecture is all about and copy it and paste it
under comment for aligning grid-tracks to grid-container and instead of 1fr, write 150px for their width and also comment out align-items and
justify-items which were for last lecture and add grid-template-rows for this lecture comment and add height of container to 1000px and with that,
you can see the container continues even after where the grid-tracks are, and also continues in the right side. So we have a bigger container than
the place where grid tracks live. So grid tracks only occupy a little part of the grid-container.
So now we're ready to ALIGN the TRACKS to the CONTAINER.

Important: justify-content which sets on the container, works both in grid and flexbox and in grid, it's gonna align the tracks inside of the container, across
 the row axis, so horizontally.
So add justify-content: center in grid container. With that, the grid-tracks went to the center of their container.
So just as we center flex-items inside of a flex-container with justify-content, we do it the exact same way with the grid-tracks in css grid.
So this is what we will use, if we wanna really center the entire content of the grid, inside of the container. We also have: start, end, space-between,
which would push each of the columns to one of the sides of the grid container. So basically it divided all of the empty space, between columns(tracks) and
that's the exact same behavior as in flexbox with space-between. We also have space-around which with that, the space on the left side is the same as on
the right side which makes that the space between items is double the space on outer sides(the space in most left and the space in most right side).
justify-content: space-evenly; the space is now ALL the same. So the space between the items is the exact same space as on the left and the right side
of each of the items.

Now if we can horizontally align the grid-tracks, we can do the same, vertically and there, we use align-content. With the value of center,
all the tracks moved into the middle of the container, vertically and for align-content, you have all the exact same options as you have in justify-content.

Important: Whenever we have <>-items in the name of prop(align-items and justify-items), that's for the individual items and if we have <>-content in property
 name, it's gonna align the entire tracks. Then, the align part of the property name always means the VERTICAL direction or the column axis.
 So align-content and also align-items means the vertical direction or column axis and justify always means that it's the horizontal direction or row axis.
So that was how we can place our items and our tracks exactly where we want them to be inside of the grid container.

Now let's select .item--6 and make it span across 2 row tracks, so: grid-row: 2 / span 2;
After doing that, you see that below item--3, there's an empty cell and it comes from the fact that automatic placement algorithm kind of tries to
keep the sequence of those grid-items in the source code and tries to kind of follow that order in source code, when it places the grid-items on our
grid and therefore, sometimes that can create these kind of holes in grid and we not always want them, so let's fix it.
Solution: Go to grid-auto-flow in grid container and add dense value to it. So now instead of grid-auto-flow: row or column set it to
grid-auto-flow: row dense; and with that we say we want no holes in our grid and we want a more dense grid with no holes and all the items are packed,
so that all the grid cells are filled with some kind of item.
In our example by adding dense, you see that the automatically added track because of grid-auto-flow set to row, is now gone.
Also in before adding dense, you saw another empty cell(a cell without any grid-item in there), next to item--8. But with dense it's gone.
By using dense, the item--8 is went to empty cell which was next to item--5 and the automatic added row is now gone. So with dense we haven't any holes and
all items are full packed and we have a full packed grid.*/
/* 15. Using min-content, max-content and the minmax() function:
I created 4th project in codepen.
Explicit grid is what we define with grid-template-rows and grid-template-columns. So if we have 8 grid-items and we just make w rows for our
grid-system by saying: grid-template-rows: repeat(2, 150px); , then we have an explicit grid and implicit grid and in this case, we would have an
explicit grid with 2 rows and an implicit grid with 6 rows(why rows? Because grid-auto-flow is set to row by default). So those 6 items are added
to implicit grid. So because CURRENTLY we ONLY defined 2 cells(yes cells, because by just saying: grid-template-rows: repeat(2, ...); we just
define 2 explicit CELLS(the default of grid-auto-flow is row)), so the remaining ones are added to the implicit grid which we didn't define.
So let's now define the columns.
So far, we have only used real units for defining columns and rows, like px, percentages or the fractional unit. So now let's say:
grid-template-columns: 1fr 1fr 1fr 1fr; or repeat(...), but let's keep not using repeat() because of the goal of this lecture.
So up until this point, we always used these normal units there, but there are some new keywords that are associated with css grid that we can use there
instead and the first one is max-content. if you use max-content of a grid-track, you see that track has the exact width, so that it can ACCOMMODATE
it's content. So the largest content in that track which we used max-content on it, defines the width(in case of grid-template-columns) of that track.
So the largest content of a column-track, defines(becomes) the width of that column.
Learn: So max-content in a column, makes that column as wide as it has to be to fit it's content and in fact max-content also tries not to make
 any line-breaks.
Now if you have a lot of content in at least one of the cells of column which the width of that column is max-content, that content would EXPAND
that column and therefore, that column becomes really wide without having any line-breaks. Because as we mentioned, it tries to make the
column that it's in it, as wide as possible without having to cause line break in the content and then of course the remaining space is divided for
those 2 columns in the middle because those 2 middle columns currently(grid-template-columns: max-content 1fr 1fr max-content) have 1fr. So those
columns because each one have 1fr 1fr, the remaining space of grid system goes to them and will be divide for each of them.

If you use min-content on the column that has a lot of content(which means a lot of width for it's content), that column track, takes the largest
width(if used on columns) that is needed to FIT it's content inside of itself without overflowing from width of the column, but if there's no height
or width anymore, well, it's content would be overflow from HEIGHT(if you doesn't set min-content for that cell on it's row).
So if the content is overflowing in heights(vertical positions) of a cell, you can use min-content on the grid-row-tracks for that cell, so the
content won't overflow from heights of the cell.
So if you didn't use min-content on item--8 , then it's width would be the width of it's largest content because of min-content on the column which
that cell was on it, but because we didn't set any min-content on the ROW which that cell is on it, the content would overflow from height of that cell.

So min-content when is set on column of the cell which that cell was on that column, the width of that cell would be the minimum width which that cell or
column has to have, in order to FIT it's content without overflowing on the SIDES(because of min-content is set on the grid-template-COLUMNS-so it has
to do with width which is on the sides). But currently because we defined the rows with a height of 150px, the content of item--8 doesn't really fit anymore
into the HEIGHT(because the row has very little height which we set in grid-template-rows of grid-container).
So what we can do is to use min-content (or max-content not in this case!) ALSO, on the ROWS. So instead of using grid-template-rows: repeat(2, 150px);
which has the fixed value of 150px, use: repeat(2, min-content).
Now the content first in the height(because of min-content in grid-template-rows) and in the width(because of min-content in grid-template-columns) of
the grid-cell which that content is in it.

With minmax() function, we pass 2 values in it and then css ensures the track will always stay between these 2 values. So if we pass 100px and 200px to
minmax() for a column, then css grid will ensure that no matter what happens, that grid column will always stay between 100px and 200px WIDTH(because width
is associated with columns in grid).
Important: In grid: Width is associated with columns and height is associated with rows.
EX) If we had: grid-template-rows: repeat(2, minmax(150px, min-content)); , it means, the rows should be at least 150px HEIGHT and at most, min-content.
So if in one row, you have not much content that wouldn't make more than 150px, then the height of that row would be 150px and if in one cell of a row
you have a lot of content, then the height of that row would be the MAXIMUM height of all of the cells of that row(so the height of the row in that case
would be grow. So it would be grew, in order to accommodate to fit all of it's content.)

EX) Let's say we want the first column to always be between 200 and 300px and the other ones should fill up the REMAINING space:
grid-template-columns: minmax(200px, 300px) repeat(3, 1fr);

With that, even the viewport width gets very small, the width of first column would never be less than 200px. So if the viewport gets very small
in terms of it's width, it will get a horizontal scrollbar, but the first column would always be at minimum of 200px and in this case, instead,
the other columns would get smaller and smaller and the first column would have 300px, until the other columns can't fit their content in themselves(if other
stuff aren't set) and in that case, the first column would start to getting less and less UNTIL 200px.

EX) grid-template-columns: minmax(200px, 50%) repeat(3, 1fr);
Now if the width of viewport is enough, then the first column would get 50% of width of it's parent which would be a grid-container. Now if we
start to decreasing the width of viewport, first off, the width of other columns that have 1fr would getting less and less and then if EVEN ONE OF
CELLS can't fit it's content in horizontal direction in itself(if other stuff aren't set!), then the first column would begun to decreases, BUT IT STILL
ALWAYS HAS 50% of it's parent's width. BUT AT SOME POINT, there will come a moment or a point, where first column is no longer 50%, but it's 200px.
Because we said that it should never be less than 200px.

EX) grid-template-columns: minmax(200px, 1fr) repeat(3, 1fr);
When there's enough viewport width, the width of ALL columns are the same, but as soon as we start decreasing the viewport's width, the width of
ALL columns also start to decreasing because all of them at that point have 1fr width, but at some point, you see that the first column is fixed at
200px width, while all the other ones, divide the remaining space between each other. So the first one stays at 200px(if there's no more space!) no
matter what happens and the others take up the remaining space equally UNTIL there isn't enough space for one or more of those other ones and then,
the ones with wider content will get the width they NEED while other ones still can decrease their width until they ALSO hit their content width and after
that(when there's no column to decrease it's width), we would get scrollbar(if no other stuff are set!). So when a cell hit their content width and can't
no more decreases it's value, it would be wider than the other cells that can STILL decrease their width, when the viewport decreases. But we set
1fr for all of them in this case, right? Why some of them would be bigger?(So this effect would happen, if we EVEN set all of them to 1fr, because
we EXPECT to all of them get same width at any moment right? NOO!)
But why is that? Why the columns that have 1fr decrease their width as the viewport width decreases, UNTIL they hit their content width and no more can
decrease their width from that point?
Because the css grid specification says: A fractional unit fills up the entire REMAINING space but it is NEVER smaller than the minimum content of a row
or a column. So ideally, all of those columns that have 1fr should be all the same, because they're all 1fr, but at the limit, when one of those columns can't
get smaller because of it's content, then that fr unit OF THAT CELL! simply takes the minimum width that it NEEDS to fill the column without overflowing(in case
of columns, overflowing to new linens of content in that cell).*/
/* 16. Responsive Layouts with auto-fit and auto-fill:
We're gonna look at aut-fit and auto-fill keywords and how build responsive layouts with them, without writing a single media query.
EX)
we have 8 grid items in html and this rule:
grid-aut-columns: repeat(4, 1fr);

But what if we didn't want to specify that EXACT number for number of columns there?
What if we wanted to adapt that first arg to number of items that we have? For example, let's say we put 100px instead of 1fr in the example, that
would create 4 columns those columns each would have a EXPLICIT width. But imagine if you want it to have eight columns there, but instead of
writing 8 explicitely, we wanted that to happen AUTOMATICALLY and that is where auto-fill comes in. So instead of number there, we can write: auto-fill and
then css grid is gonna automatically create 8 tracks for us and ACTUALLY IN FACT, it's not just 8 tracks(it's won't just create tracks as equal as
the grid-items that we have), it creates 10 tracks! and why 10 and not equal to number of grid-items which in this case is 8?
That's because our container is 1000px and we speicifed that we wanted 100px columns and so 1000 divided by 100 is 10 and therefore, it then creates
10 column tracks and then after that, it puts our items in there.

Learn: auto-fill automatically creates as many tracks with the desired width that we specify as the second arg of repeat() for example, as fit into the
 (grid-)container and in this case, that's 10 tracks.

Now what's different between auto-fill and auto-fit?
Now if we use auto-fit in our above example, it actually STILL created the 10 columns and how we can see it? By seeing the column-lines number in devtools.
So if you see that, you'll see the number of LAST line number which is 11(the column line) and this means the grid actually has 10 columns.
Learn: So you can see it's 10 columns because it ends at number(LINE NUMBER) 11. But what auto-fit does is that it collapses those tracks and gives it
 a width of 0 which then would create that extra space that you can see(because it created 10 tracks but as you can see in line numbers, but for those
 2 tracks, it gives them a 0 width).
 So basically it is, as it only created really 8 tracks and actually in devtools of firefox and in it's layout section, you can see that we have
 only 8 column tracks but the last column-line-number is 11! So it creates those tracks and then leaves that empty space there which we can then fill,
 if we want it.
Important: So with auto-fill, it creates 10 columns, so as many as fill in there, while with auto-fit, it STILL creates those 10 columns, but then
 collapses the ones that are empty to have a width of 0.
 (The empty ones, means if we have 8 grid-items and the specified width for each of those items is 100, that means
 we would have 200px empty space which would be an empty space, because the auto-fit makes 10 column tracks but then make the width of those 2 column tracks
 which with those 2 we would have full width of container, to 0.)

auto-fit actually collapses those tracks and gives it a width of 0.

What this allows us to do is to use minmax() function as the second arg which would make a beautiful solution.
EX) 8 columns in html
grid-aut-columns: repeat(auto-fit, minmax(100px, 1fr));

With that, it occupied our entire grid-container EVEN with having 0 width for those last 2 columns in this example! So basically filling that
extra empty space that was left over, by expanding those columns into MORE than 100px of width(because they're now 1fr).
Now let's see what happens as we decrease the width of viewport. As you start reducing, for example if we reduced to 831px, I mean the container has
831px width, we can STILL fit the 8 columns in there, right? Because each column has to be AT LEAST 100px. So 100px has to be the minimum of each
column and right now we have 831px, so we can still fit 8 columns in there. But if you decrease further, the last grid item moved into the next line
and that's because right now we only have 7 columns there because we only have 796px width for grid-container, so we can no longer fit 8 items with
100px each in one row, because for that we would need at least 800px and so what auto-fit here(when there isn't enough space for all items
to fit in one row (or column)) does, is that it creates instead of 8 columns, 7 columns and this would keep happening as we decrease that further.

EX) 8 columns in html
grid-template-rows: repeat(2, minmax(150px, min-content));
grid-aut-columns: repeat(auto-fit, minmax(200px, 1fr)); and current width of container is 1007px:
we would have 5 columns on the first row and each of them has 201px width and as we decrease it, we no longer have enough space for 5 columns and
so we end up with having 4 columns in each row which each would have still above 200px limit. Now by decreasing it further, we would have 3 columns in a row,
because it no longer has the space. Again, container has 797px, it no longer fits 4 columns with each having 200px wide, because for that,
we need 800px, which we don't have anymore(we now have 797px) and so we have 3 columns in one row which means 3 columns.
Now you can see tht we have the third row which hasn't much height because it isn't styled(it's an implicit row) because in our example we defined 2
EXPLICITELY rows, so that third line is an implicit one, so let's
style it:
grid-auto-rows: 150px;

So our layout is responsive without writing a single media query. So the trick with auto-fix and minmax(<fixed number>, 1fr) which has
a fixed number and 1fr is a good trick which will then automatically adapt to the screen size, without having to write media queries.  */
/* SECTION 9. Nexter Project  Master CSS Grid Layouts!:
1. Project Overview and Setup:
Entire layout of the page is grid and also we use grid in smaller components.
In this project, we have 1 file for each part of the website, but we'll talk about why we did it this way.
In start npm script, at the same time we watch for sass changes and we have our devserver. The last 4 npm scripts are for build process.
With npm install, it looks at our package.json file and installs all of our dependencies that we have listed in that file.

You can use npm run start to start development. Also we can specify the browser in live-server command. Because if we just run live-server
without anything, then it will basically launch our default browser for the devserver and so it will launch chrome but because of css grid
devtools we have been using firefox, so write: --browser=firefox

For the npm script named "start", we don't EVEN need to type: run. We just need to write: npm start. So without writing npm run start and
just by typing: npm start , we can run a npm script named: "start".

2. Building the Overall Layout - Part 1:
- How to build a complex and modern layout using advanced css grid techniques
- How to choose different row and column track sizes for different types of content

Sidebar on the left side of page, goes all the way from top of the page until down. So that's the first part of the layout.
Then we have that dark blue part left side which it's left side is header and on right side, we have another part of the layout.
Down there, we have features of the company, so basically describing how the company works and so that is another part of the layout.
Down there, we have testimonial section with one part on the left side and then another part on the right side.
So it's a testimonial of some people who found their perfect home.
So we call that a story. The left side is one part of the layout which is like a gallery, like the pictures and the right ise is the content of
the story which is on the right side and we can treat them as two parts of the layout. Down there, we have the next section of the page,
then down there, we have a typical application of grid which is that gallery and then, the footer.

So we have a total of 8 parts in our layout. sidebar, footer, gallery, homes, story(which itself has 2 parts), features, left side of the header,
right side of the header.

We already(from the beginning) put the container class on the body tag, why named it container? Because it's gonna be our grid-container and
all of those parts of the layout that we just saw and said, are grid-items which we're gonna place on the grid.
So let's start by writing the markup for sidebar.

After writing the markup, let's give each of them a background-color, so we can better see what's going on. In this project, we already have
a file for each of them in the sass folder.

3. Building the Overall Layout - Part 2:
Let's define the column tracks of our layout and then place the grid items in it, so that we end up with our final design.
It's very common in web design to use a design grid, with like 8 or 12 or 16 predefined columns and that's also what we're gonna do in
this project. Now it may not really be necessary for this design, but as I mentioned, grid systems like this one are widely used in web design.
So for example, bootstrap has a 12 column grid. We start with an 8 column grid here. So imagine that we wanted just a very simple 8 column
layout. So in .container class, say: grid-template-columns: repeat(8, 1fr); and this would produce 8 equally sized columns occupying the
entire viewport.
Currently, because we have 9 grid-items, 8 of them(because we have defined 8 columns), will fill the first row of our grid-system which that
first row is 80vh(80% of viewport height) and the last grid-item HAS TO go to the next row(because we only have 8 columns defined).
BUT that's not quite what we want, because what we want is actually to have like those fixed columns in middle of viewport like what we want in
features section. What that means is that those columns in the middle, they have actually a fixed width. So we want those 8 columns to have a
fixed width(but also when we decrease the width of viewport, they must adapt themselves to their content right?) and also remember that
usually we use sth like 1140px or 1200px, so sth between 1100 and 1200.
So let's divide 1140 by 8 which results in 142.5 and that's approximately 142px. So let's simply say it's 140px and therefore 14rem. So right:
grid-template-columns: repeat(8, 14rem);

But now suppose that we decrease the width of our viewport and the columns doesn't even adapt at all and that makes sense, because they're
just fixed-width columns and therefore, we can fix that by using minmax(min-content, <fixed width>) instead of <fixed width>.
So we say that the maximum should be 14rem, but it can be lower(this is the meaning of minmax() right?). But never below the min-content, which
results in: minmax(min-content, 14rem)
So the minimum size that it should have, in order to fit the content in there, is min-content.
Let's think about it again. We want to have 8 columns and we want the width of each of these columns to be between their minimum content(which
means: min-content) and 14rem. With that, if you now decrease the width of viewport, you see that the columns are starting to adapt
to the viewport width. But also it(each column) never grows larger than 140px(14rem).

Also we want sth else and that's the sidebar. So we want 8 columns in the middle, but then on the left side of all of these columns, we have
the sidebar and so that's also a column track. So let's add that column track to our columns defnition and we want that column-track to be
90px wide so 8 rem(also it's on the left side of our 8 column tracks which are in the middle, so we put that sidebar column, on the left side
of repeat() function).
So instead of: grid-template-columns: repeat(...); , type: grid-template-columns: 8rem repeat(...);
So with that, we added ANOTHER column to our existing columns. So right now we have 8rem for the sidebar and then our 14rem for each of columns
beside that sidebar.

Now the last step is to center those 8 columns which each are 14rem width, between end of the viewport(which is right side of viewport) and
that sidebar column-track. Because we don't want those 8 columns to be centered IN THE VIEWPORT, BUT BETWEEN the sidebar and the end of the page(
right side of viewport). So between the sidebar which is currently on the left side of viewport and right side of the viewport and not centered
in the viewport itself.
How can we do that?
Well, we could simply add two more columns. One to each side of these 8 columns in the middle. So one on the left side of these 8 columns and then
one on the right side and we want both of those new columns to occupy the REMAINING of the SPACE. So instead of: 8rem repeat(...) for columns,
type: 8rem 1fr repeat(...) 1fr;
Why like that? Because the translated of this sentence: Add one new column to left side of our 8 columns and right side of it, means
add 1fr column to left side of repeat(...) and it's right side!

So now we have our 8 columns in the middle and then on the right side and on the left side, we have one column that occupied the remaining space.
Also on the left most, we have the sidebar. So now if we decrease the viewport width, you see that those new left and right columns are the
ones that start to shrink(getting smaller in width) FIRST. So they started to shrink because they are the one that occupy the FRACTIONAL SPACE or the
remaining space and that's kind of what we wanted. Having our eight columns centered right in the viewport.
Now if we hadn't that sidebar column there, then you could've used the margin: 0 auto, trick for centering. So where the margin on the left and
right side are set to auto and then that would center the element or in this case, all of these 8 columns in their parent(viewport??),
or we could also used the justify-content prop, but that wouldn't have been perfect in this case as well and actually another reason why we
want to do it like this, is because we would have some sections(like story section) that go from one side to the other and that's what is called
the full-bleed sections. BUT in features section, our content in that section is occupying ONLY our eight columns which are in the middle
and are not from one side of viewport till the end of it, in contrast of full-bleed layout, but for example in story section which is a
full bleed section, it goes all the way from the end of sidebar column, to the end of viewport on the right side and the same thing for gallery
section and footer and also the header with realtors section. But for example in homes section, the content of that section are
only in the 8 columns and not out of them.

So those are full bleed section and therefore we NEED those columns on the left side of our 8 centered columns and right side of them, in order to
basically BREAK OUT of our predefined 8 columns grid that we have in the middle of the page(they are in the middle of page, if you also
consider those new left and right columns and the sidebar!) and so that's another thing which this layout allows us to do perfectly.
So this is perfect for having full-bleed sections in the middle of some 8 column sections. So having a couple of design elements which are
centered in the viewport like we have with these 8 columns, but then sometimes we have some full-bleed sections in the middle of that.

Again, we started with an 8 column layout which are those 8 columns we have, then on the left side we added that sidebar and then we added
a column on left and right side of our 8 columns group, which both of those 2, occupy the remaining or fractional space, in order to CENTER
that 8 column group in the middle of the PAGE and then if you want a full-bleed section, we can occupy these columns and have a section
that goes all the way from the sidebar(in this case)(end of sidebar-right of sidebar) to the edge of viewport in right side. If that sidebar
didn't exist, in full-bleed layout, have a section that goes all the way from LEFT side, all the way to right side, for example and with that,
we can kind of break the inner 8 column layout.

Now in order to make our life easier when we start placing the items, let's name these column tracks. For example when you want name the
8rem column, you say: [<name>] column1.
Also remember that the grid-line can have multiple names.
Son now instead of: grid-template-columns: 8rem 1fr repeat(8, minmax(min-content, 14rem)) 1fr; we say:
grid-template-columns: [sidebar-start] 8rem [sidebar-end] 1fr repeat(8, minmax(min-content, 14rem)) 1fr;

Why we named full-start? Why the name "full"?
Because that is where we want to start the full-bleed sections. So imagine that we have a full-bleed section, then that would start right AFTER
THE SIDEBAR(in our project, if it wasn't a sidebar, well, the full-bleed section would start from the left of viewport till end of viewport) and
it would go all the way until the END. THEREFORE, we need to name the LAST grid line(which is the line that our full-bleed layout ends), full-end.
Because that's where our FULL(like the name that we choose for those two lines!)-bleed section ends.

Now after naming the second line, full start and the last line, full-end, we call the grid line that comes after first 1fr column, center-start.
Because that is the beginning(start) of our eight columns and that's the part that is gonna stay centered in the middle(so we call it: center)
and then the grid line after those 8 columns is called: center-end and now finally, we also want to name all of those 8 columns which are
generated with repeat() function and we can do that, by creating a set of named lines and we do it, INSIDE the repeat() function and
remember that this code: repeat(8, [col-start] minmax(min-content, 14rem) [col-end])
is gonna create 8 "col-start"s, starting from number 1 to number 8 (so: col-start-1, col-start-2 ..., col-start-8) and the same ting for
col-end.

Now let's start by placing the sidebar. So go to _sidebar.scss and we want the sidebar(it's column lines, not row lines) to start from
the grid-line called "sidebar-start" to "sidebar-end" and then the second step is that IN TERMS OF ROWS, we want it to span all
the way from the beginning of the grid to the end. So use grid-row prop with the names of lines for it. We want it to start right at the
beginning of our design and goes all the way til the end and what is the keyword for the end? -1
Important: The keyword of start is : 1 and for end is: -1.(if they haven't any names)

Right now we only have 2 row tracks and therefore, right now the sidebar is not as tall as it is in the final design, but it will start
increasing as we add more rows to the grid.

Maybe you're wondering why we're not naming the rows?
That's because, in an overall layout like this, the focus is always more on the columns and not so much on the rows. So sometimes you might not
even want to size the rows, because sometimes all you really want to do is set all your rows to fit your content(min-content ...) and in that case, you
only need to define the columns, because the columns are always more crucial.

Now let's go to features. For that, we know that features section, go from end of first 1fr column, all the way to start of second 1fr column(or
all the way till end of those 8 columns). Or in other words, from the beginning to the end of our central 8 columns.
But why? Isn't that true that features part is from sidebar to the end of viewport in right?
NOOOO! The content is crucial not the actual section! The CONTENT of that section is from start of 8 columns till the end of 8 columns.
So from: center-start to center-end grid line. Which in between these 2 lines, we have our 8 centered columns.
For now, let's leave the header and top-3-realtors for later, because they're complex.

Let's continue with gallery and footer. We can see that the gallery goes all the way from one end to the other end(full-start / full-end).
So we called it full-... , the full-bleed section and the same goes for footer.
So now, the gallery spans all the way from sidebar to the end of viewport in right as well as the footer.

If you want to set the font-size of the direct children of body, you can say: body > * {...}

For homes section, we want it to be the same as the features section. So just like the features section, it is occupying the
our central 8 columns.
Of course we could used just the line numbers and simply make:
.homes {
  grid-column: center-start / center-end;
}
to:
.homes {
  grid-column: 3 / 11;
}

Now let's think about header and realtors sections.
What we want to do, is to give 2 parts of our 8 columns in center, to the realtors and 6 columns of that 8 columns group, to the header.
So 6 out of 8 columns are for the header and 2 out of 8 columns are for the realtors and then of course, we add the outer left part(the
second 1fr column) to realtors and the first 1fr column to the header, so that we end up with a full-bleed look and so that's why
those columns in the middle are so useful. Because they allow us to build different kind of designs.
For example in story sections, you can see that we used that grid line in the center, to put one part of the story section on the left side
and the other part on the right side of that central line.(so that middle line which is on the middle of 8 column group, is actually
responsible for dividing those 2 parts of story section).
So in that case, it's 4 columns for the picture section of story and 4 columns for the content part of the story section.

Let's go to header file, the HEADER(not realtors section!) starts at full-start(right after the sidebar(or in better words, where
sidebar ends, there, we have the full-start line)) and it ends after the sixth column(the column right after the full-start is col-start 1).
Remember: When we have a named SET(a list of them) of grid lines then we have to use the numbers after the specified name that we chose for each
of the columns like the name we chose in repeat() and in this case, it ends after the sixth column which the name of that column is col-end 6.
Important: So when you have sth like [col-start] in the repeat() function, it will get: col-start 1 , col-start 2 and ...

and now the realtors.

Now let's work on story__pictures and story__content . The story__pictures goes until the fourth column(col-start-5 or col-end-4) and then
the next one(story__content), it starts at the beginning of fifth column. So go to story file.

Now we finished our overall layout.

Now if you decrease the viewport's width, then of course our eight columns in the middle, ALWAYS stay nicely at the center, right?
and you can see this behavior at the homes section, which always stay at the center even if we decrease the viewport and that's exactly
what we defined. But when you approach a small width of viewport or in better words, when you approach to the edges of 8 columns,
you can see at that point, the space on the left and right side of the for example the homes section(which is completely bound to those 8
columns), almost disappears and that's because those column tracks between the edges of 8 columns group, are defined to be 1fr, so 1 fractional
unit(1fr of the remaining space) and so they do the exactly what we told them to do. BUT, we actually don't want them to be QUITE LIKE THAT!
Because we usually want to have some margin or space between the content and the (margin or the actual page) of the page and in this case,
that space between the actual content and the page, really gets low and they start to stick to each other and also the 8 column group also
sticks to the sidebar and that's not ideal and what we can do is to use the minmax() function.
So instead of those 1fr units in: grid-template-columns: [sidebar-start] 8rem [sidebar-end full-start] 1fr
                         [center-start] repeat(8, [col-start] minmax(min-content, 14rem) [col-end]) [center-end] 1fr [full-end];

we can say: minmax(6rem, 1fr) // between 6rem and 1fr
and with that, we will always keep a minimum of 6rem on the sides of 8 columns(which those sides are those columns between the sidebar and
8 columns group and between 8 column group and the edge of screen in right.)
So with that, we ensure those 2 columns never get smaller than 6rem and instead, what will START to shrink when there's not enough space to
fit those 14rem columns in the viewport, will be the columns THEMSELVES and not those 2 columns on the sides, because they now have a MINIMUM
width, so they would never gets less than 6rem. So those 8 columns are the ones who will start shrinking when there's not enough space for
those 2 other columns(on other sides) to shrink ANYMORE!
Now as we approach to the 6rem width of those 2 columns, those 2 columns won't shrink anymore and instead the 8 group columns will shrink.
So that 6rem is the minimum which those 2 columns will always have no matter what and they will have 1fr if there's enough space.
So as we decrease the viewport to where the width of those columns arrive to 6rem, they won't get smaller anymore and instead the 8 columns will do
instead and so what this does, is that it ensures that there's always enough space(tudor said margin!) between the content the end of the page.
Now we can build the sections one by one.*/
/* 4. Building the Features Section - Part 1:
- How and why to create grids inside grids
- how to create responsive component without media queries
- how to build a small component using css grid

We chose to create the features section first, because it's simple than the header or the realtors sections and we will then come back to that
top part(header and realtors).
In features section, what we have are basically 6 features(grid-items) laid out in a 2 by three grid. So three columns and two rows and
so this is a perfect use case for using css grid. So let's again START doing that in our markup(in features section).
Learn: In emmet, we can use $ to number stuff. So .feature$*6 will create 6 <div>s with class of feature1, feature2 and ... .
 But we can also emmet to introduce some text into the html element right off the bat and for that, we just have to use {}, like this:
 EX) .feature{feature $}*6
 this would create 6 <div>s with class of feature and the content of them would be: feature 1, feature 2 and ...
 So: <div class="feature">feature 1</div>...

Now go to features file. We know that .features itself, is a grid item. BUT now we want that grid-item to be a grid-container too and so
that's just the same thing as we have in flexbox, where a flex-item can easily become a flex-container itself too! In this case, all we have to
do is to write: display: grid; on the .features .So with that, .features class is a grid-container and a grid-item simoninously.

It would be helpful to have sth called a subgrid in there and that's actually sth that's coming to css grid in the second level of the specification.
But right now, sub-grids aren't available. So what will a subgrid actually be?
Basically it will allow a grid which is inside a grid, like in the case of features, to like snap it's tracks to the parent grid.
For example, align it's columns with the columns of the parent grid. So in the example of features, we could make it so the columns of that
small grid(the columns of .features grid), would AUTOMATICALLY be where the columns of our overall page layout are.(because the overall page
is direct parent of .features which itself is a grid and we want it's columns to be where the columns of overall page is) and actually that would
be helpful here, but right now that's not possible! and so we need to MANUALLY create new columns for the feature grid-container, because again,
it won't snap it's tracks to it's parent grid which is the .container class. For example if .features were subgrid, we could create a grid(.features)
where we could automatically say the one column should be like those 2 left most column tracks of .container grid, so basically snapping to those
tracks of it's parent which is a grid-container. But currently that's not possible and so we're just gonna manually create our grid.
So let's start with the columns of that grid and we want 3 columns for .features grid-container and therefore we just say: repeat(3, 1fr); which
means 3 columns with 1fr unit for each(NOT 1/3 fr for each!!!) which this would create 3 equally sized columns.
Now about the rows, we don't actually need to specify anything for the rows. I mean, we could do it and we would do it basically like:
grid-template-rows: auto auto;
But that's not necessary at all, because that's just what's gonna happen anyway if you don't define anything at all and so we don't need that.
What actually will happen is that we create an IMPLICIT grid. So all of our items will be placed in an implicit grid and not in an explicit grid.
Because we don't define the rows, so we have like zero cells defined for our grid! BUT that's not a problem at all, it works just the same.
So let's get rid of explicitely setting grid-template-rows for .features .

In devtools of firefox and in layout section in right panel of elements tab, if you select on section.features , it will deselect the
body.container grid layout, so it will basically deselect the overall layout in this case. So we can either have that one(body.container) or
the other one(section.features) and in features section, we now have a three by two grid
Important: And you see that some of the lines(in this case, the lines between cells and between the bottom cells and the bottom edge of grid which
 in other words is bottom lines of bottom cells in .features grid) in a selected grid layout is dotted and that means those are row tracks of
 an implicit grid.
Now we can get rid of debugging huge font-sizes and paddings and background colors and also add some margin to top and bottom of .features
grid-container(which is also a grid-item simontiniously).(The debugging styles that were in base.scss:
.container {

  & > * {
    padding: 40px;
    font-size: 3rem;
  }
})

Now we're ready to start filling the grid-items of .features with the actual content.
The font-size and font-family of paragraph texts in content(the usual text) is different than header and those header elements are <h4>, also
the name persons in realtors section is also <h4>, the heading in realtors is <h3>, that big header in header section is <h1> and the big header in
story section is <h2>, the author says he could done that differently, but that's up to us to how we do it in our project.
So that's the hierarchy the author used for the headings.

In class name of <h4> which is heading-4 you can see that we're already using like a reusable style and so heading-4 is like a component that
we're gonna reuse throughout the page later on and so that's not really part of the feature block and the feature component itself.

Of course we could leave the same text in all those <p> elements of 6 features, but then it would look weird and not natural at all and
also tutor wants to show us sth that happens when we have different amount of text there and so it's useful to have different text in those
6 features.*/
/* 5. Building the Features Section - Part 2:
We have the icon and the text and the heading separately, to style.
So we have .features and also .feature . So this .feature component in theory, would be reusable in another page. So it's completely independent
from the .features class. But we still put them in the SAME FILE though, because they are closely related and having these classes in different
files would make us jump around a lot rhough the different files and that would be terrible for recording videos!!! and so basically each of the
section now got it's own file and there, we have the overall element which is like the container of those components or elements.
(like the .feature component in features section)(so for example the .features class which is for the overall element in features section
which this section has it's own file). But again, that .feature would be completely reusable somewhere else later on the page or if we had
another page on our website, we could again use that class.
Now let's start by styling the .feature__text .

The width and height of a svg icon would be usually the same number.

In future we will have also heading-1, ... and we put them in typography file. So let's actually write all of them in that file, why not!!
We're gonna use $font-display font which is josefine sans for all of the headings.

Remember: We included some certain font-weight in the html file from the google fonts.
Important: We want all of those .heading-<x> classes to have some properties which in case of this class, we want them to have 2 properties
 and so that's a perfect use case for a sass extend. For that I created a placeholder named heading and the syntax for it is: %heading.
 So when we say: @extend %<name of placeholder>, what's gonna happen is the class name that we wrote that extend in it, is copied instead of
 where %<name of placeholder> lives.
EX) When we have:
%heading {
  <some css rules that every class that extend this placeholder will get>
}

.heading-1 {@extend %heading;}

What would happen is that the class name(.heading-1) is gonna copied instead of where %heading currently leaves. So it would be:
.heading-1 {
  ...
}
which in above, the place where .heading-1 lives, was the place where the placeholder lives, right?
So in typography file that we have this placeholder and @extend, what's gonna happen it's like, as if that .heading-1, .heading-2 ...
will be copied to that placeholder(%heading).
So it's not a mixin, because a mixin works the other way around. So with the mixin, the code inside the mixin that we declared, will then
be PASTE into each of .heading-1 and ... .heading-4(the selectors that @include that @mixin) but with @extend it works the other way around.
So basically those selectors are copied into a huge selector??(the author says that but I think, the placeholder is the right word for that huge
selector!) which then makes the code inside itself, apply to all of those selectors that were copied in the place where placeholder lived.

Now remember that we want to use that .heading-4(and all other heading classes) in different situations throughout the page.
So we want to use it on the .features but also in the realtors section and in names of our realtors which in that place, the element
that need .heading-4 is white and not dark(which is the color for .heading-4 we have in features section) and therefore, we need to do that
with a modifier class. So let's add some modifier class with sass nesting, inside .heading-4 and we also HAVE TO add one of those
modifier classes to html too, because the color of <h4> would be defined in those classes and not in .heading-4 (because that's actually
the responsibility of modifier classes, so they would be ALSO added ALONGSIDE the normal(block or element) classes)
So add .heading-4--dark(the dark version or modifier which we know a modifier has 2 dashes) next to the heading-4 in those 6 features.

In each feature which is a small component and we have a two-dimensional layout there. Because we have the row axis and the column axis.
So it's really a two-dimensional and so why not use a css grid?
So we will have a two-by-two grid(I don't mean the overall layout of features section, but the overall layout of each feature).

So we're gonna have have that two-by-two grid and then in there, we will place three elements. So now go to feature file and .feature class there.
We know that .feature ITSELF, is a grid-item, will now also become a grid-container. So we have a grid inside a grid, inside a grid!!!
So just like what we had in flexbox, we can nest the grids really deep. So add display: grid; to .feature , then define it's columns.
Now what width do we want to have for the first column of .feature?
The first column will contain the icon and we already know the width of the icon, it's 4.5rem and so for that first column we could simply put
4.5rem as well. But instead of doing that, we will simply put auto OR we could use min-content or max-content. So let's actually use min-content,
why not?! Because this way, if we eventually wanted to change the width of the icon, then the width of the first column which the icon is
in that column, will AUTOMATICALLY ADJUST, without us having to change anything! But if you were used a fixed number for width of that column
and if you changed the width of content(in this case the icon) that are in that column, you HAVE TO change the width of column as well, so it's not
good and then the rest of the grid, so second column, will occupy the rest, so 1fr.

Now as for the rows, again, we don't really need to specify them, because all we want to happen is them to be the size of THE CONTENT that is
inside them and so once more, we don't really define them and probably you start ot see this emerging like as a trend,
Important: so, many times, we don't really define the rows, we just define the columns.
and in a real word scenario, that's actually many times the case. So many times, WE JUST WANT THE CONTENT TO DEFINE THE ROWS and so in that
case, it's not really necessary to define the rows. We will have other cases where we will define the rows, but for now, it's good like this
and it works perfectly fine like this.

Currently the result of each grid-item layout for .feature is not good yet. Because you see all 4 grid-cells, the first grid-cell
one is much larger, than the icon and that's because right now, we only have 3 elements(yes we ultimately need 3 elements as we have currently,
but the paragraph must be placed under the ) in those grid-cells and so the third one(which is
the paraggraph) of course, because of the auto-placement algorithm, gets placed under the icon cell, so what we can do, is to place
the grid-item that has the paragraph, in the right grid-cell, but actually what's even better, is to make the icon grid-cell span ALL the way
until the end(vertical end), so that we end up with that left most vertical grid area for that icon alone. Because right now, the upper
row is also as high as those icons, but actually we want it be as high as the heading text and not as high as the icon height and so if we
had all of the left most column(or those 2 rows) for only that icon, then that would happen perfectly fine.
So go to .feature__icon and we want it to have the grid-row prop set to start at 1 all the way to the end, or span 2 cells. In this case, -1 or
span 2 is really the same, we could just add -1 and then we're sure that it goes all the way until the end.
Important: row props will define the height of grid-cells and column props will define the width of cells. In this case, for the icon,
 we define it's grid-row, so in other words, we defined it's height which is from line number-1 till the end.
and so now automatically, the <p> should get placed in the right-bottom cell.
BUT! For some reason, that didn't happen! WHY?
Important: Because -1 means NOT the end of the grid, but the end of the EXPLICIT grid. So -1 would be the last explicit grid-line,
 but we didn't really define(explicitely- but there would be some implicit row lines definitely) any grid-rows(why rows? Because we used
 -1 on grid-row) and so there's not really an explicit grid in that casae and so that -1 there, doesn't make much sense(again because there's
 no explicit row grid that we define in this case).
So instead of just -1, we should add span 2 which results in the same grid in that case.
So again, the -1 only works with an explicit grid but we had an implicit grid in .feature grid, because we didn't define the rows and so
it didn't work as expected, but with span 2, it does work as expected.

In inspect of grid, it doesn't really highlight the spanning going on(span 2), but it doesn't matter because we can see it by ourselves
and you can see those icons in .feature is also in some parts of the second cell(the cell under the top left cell-so the icon is in 2 cells,
because it now spans) and so the top left cell and bottom left cell is like all the same cell.
So we spanned the icon across 2 those 2 cells which would cause the <p> to go to the bottom right cell.

Now let's add some space between the columns and rows. So add grid-row-gap(the gap between rows) and grid-column-gap(gap between columns)

Now the icons need to move to the top a bit. So basically to center, the center(yes the center of icon) of the icon with the heading,
we need to move the icon to the top and that's sth we have to do manually. So we can translate the icon a bit to the top.

The second issue that we currently have, is that you can see in the last column in features section which in there, in both cells of that
column, the number of lines of <p> is 3 and the space between the heading and <p> is huge. So I mentioned before that I wanted to have different
text in different <p> elements of each 6 .feature and that's because the author wanted to show us how we can fix exactly this issue(the
issue is, when we have 4 lines of text in <p> of .feature, the space between heading and that <p> is ok, but when we have 3 lines of <p>,
the space between heading and <p> is huge).

Now if you inspect the .feature which has huge space between heading and <p>(by going to layout tab and check the div.feature element that
has this issue), you can see that the upper row of grid layout of that particular(the .feature that has 3 lines for <p>) .feature , is larger(has
more height), than the rows which in there, the <p> has 4 lines.
So why is this happening?
Because the .features grid which contains those 6 grid-items, makes it so that all of those grid-items fill the entire CELLS and(in other
words) so that's because of the align-item's property which is by default set to stretch. align-items is a prop that controls the alignment
of grid-items along grid-cells and those 6 features are grid-items of that .features grid and currently(by default), the align-items prop is
set to stretch. So what do we do if we want all of them(grid-items) to start at the top? So basically move all of them to the top?
We just have to set the align-items prop on the parent container(grid-container), to start. So do that on .features .
By doing that, you can see that those particular grid-items(which have 3 lines for <p>) is now no longer the exact same of the grid-CELL but
JUST the size of it's CONTENT, moved all the way to the top, just as we specify at the grid-container.
Important: So by default, the size of grid-item is the same as the size(height) of it's grid-cell(s), because the align-items prop is set to
 stretch.

Of course we could also set align-items to end(across the column-axis) and then it would move the grid-items that are smaller than other
grid-items, to the end(to the bottom of their grid-CELL).

Now if you reduce the width of viewport, you see that each grid-item of .features grid-container, gets narrow and narrow and looks bad.
We want to make that responsive, without writing a single line of media query. So we want the features section to when the viewport arrives
at some point in it's width, the text of each grid-item gets smaller and that's because of media query, BUT that's not what I'm talking
about here! so what happens is that at some point, instead of a 3-by-2 grid, we would have a 2-by-3 grid(2 columns and 3 rows) and then
if it gets smaller, the grid would become a 1-by-6 grid and we can do this, even without media queries.
Important: All we have to change in the grid-container(in this case, .features), is grid-template-columns prop and define some new column tracks.
So I commented out the old unresponsive grid-template-columns.
The trick is to first of all, we use the auto-fit keyword and remember what auto-fit does?
Important: It simply create as many tracks as can fit, based on the width that we define, and the width that we define there will be
 with the minmax() function. So use minmax() as second argument of repeat() or ... and we say that the width should always stay
 between (for example 25rem) and 1fr unit.
So again, the width of each of the tracks(in case of grid-template-columns, the width of each of the column tracks) should always stay
between 25rem and 1fr unit and based on this(based on minmax()), css will add as many tracks(in case of .features, the column tracks) as fit
in the container(auto-fit).

So we start with 1120px for the grid-container and now let's reduce the viewport width and remember that each column (track) can have
UP TO(maximum) 250px and at some point, it no longer could fit 3 columns and so it reduced it to 2 columns(so when grid-items has less than
250px width, one of the columns would be push to the next row and then the container would be two-column tracks) and now you see that it's
even more crucial to use align-items set to start and not stretch(default). Because for example in the second grid-item, in reduced width of
grid-container, you can see we have a lot of empty space between the bottom edge of <p> and bottom edge of it's grid-cell and that's ok. In
other words, in that situation, the size of the second grid-item is equal to it's content size and not the cell's size and so
without the align-items set to start, it would look weird.

Of course we could change the 250px or 25rem that we used in minmax() to sth else, but the tutor found that it works well in that particular
situation.

So in .features section, we used 2 grids there, one big grid which could fit all of those 6 grid-items, so one grid-item for each feature and
then each feature is a grid-container ITSELF which then itself contains those 3 grid-items(icon(spans across 2 grid-cells), heading and <p>, so
in there we have 3 grid-items, but INITIALLY had 4 grid-cells, which then transforms to 3 grid-cells, because the icon item spans across 2
cells).

Grid allows us to nest as many grids inside of each other and that's helpful to create even very small twp-dimensional layouts.
So we could have used like flexbox for each of those feature boxes, but then we would have to mess with margins, so we would have added a
margin to the bottom of heading OR top of the <p> and that would have added some extra complexity.

So grids can also be for very small comps as long as they are two-dimensional.*/
/* 6. Building the Story Section - Part 1:
- how to deal with overlapping grid items
- why images are special and behave differently than other grid items
- how to decide if flexbox is a better tool in certain situations

Let's start with right side(story__content) of story section which we put some elements in there and in the end also center that
content vertically in that container.

In story__content, we have two special symbols, one for opening the quote and one to closing the quote. The first especial entity is:
&ldquo; and next: &ldquo;

For class name of <p> inside story__content , we're using the name of the block which in that case is "story" but in <h3> and <h2> we didn't
do that, because those classes are reusable, so we didn't use the BEM convention for those classes.

First let's add some padding to the story__content box.
The grid-column props that we used for &__pictures and &__content in story.scss file were for placement of those 2 grid-items(&__pictures and
&__content) in our overall layout grid.

Now let's open typography file and style the heading-2 and heading-3 and we CAN(we're ABLE to) set the font-style to italic because
we included the italic style in the beginning of html file(400i and 300i) and also for heading-2 , we want a light and a dark version.
Because we're gonna reuse it somewhere else on the page with a light version.
Right now we want the dark one, so let's go add that there.

Currently, we have a problem in heading-2 of story__content and that's because of that huge line-height that we defined which is 1.6(I think
it's the default value and we didn't define anything, the tudor said that we defined 1.6!) and so let's put that to 1 there,
so with that, we don't have all of the space between lines of that heading-2. So in .heading-2 class, put line-height: 1;

We're ALSO gonna style the .btn class in typography file!!!
Since it's a button element, we need to also get rid of the border and also border-radius, because by default, it has some border-radius and
we don't need that in that case.
So border: none; and border-radius: 0;
The button doesn't have that hand cursor by default, so we need to define that for button.

Let's make the .story__text bigger and italic.

About the spacing inside .story__content elements, we really shouldn't hard-code the margin-bottom props for those 2 headings in .story__content ,
because, again, we're gonna reuse them throughout the page and so if we add some margin there which would be good for that situation(the .story__content
situation), but then that margin might not be good for other situations in other places of our page and therefore, we're gonna use some helper classes
there. I actually gonna add those helper classes also to typograpgy file, because we don't want to just create another file just for that.

mb stands for margin-bottom and sm stands for small. With these abbrevations, we don't have to write out huge class names. hg stands for huge.

There's sth happening in css right now where people are starting to style their entire pages using only those small and unique classes(like what we
did with utility classes) and that's called atomic css and it's useful to use those classes in some points(sometimes it's useful).
Now let's use those helper classes that we defined on headings inside elements of .story__content .

We want to use .mb-lg for .story__text , but wait! instead of putting .mb-lg on .story__text, we could put margin-bottom: 4rem; directly on the
.story__text , because .story__text class isn't a reusable class.
Important: Whenever you have a reusable class used on an element and also you want that element to have some OTHER styles OTHER than the styles whcih
 that reusable class provides, you HAVE TO use a utility class on that element, instead of manipulating that reusable class with styles that you
 want to add! But when you have a custom and specific class used on an element and you also want to add some styles to that element aside from that
 custom class, you shouldn't use any other class or helper class. In this situation, you can simply put the styles you want to add, to that added
 class and not add another class just for those new styles.
So now, add a margin-bottom to .story__text , instead of adding a new class to that element. So in that case, instead of using a helper class there,
it's not really necessary, because it's not a reusable element(actually class! not element) that we want to reuse somewhere else on the page.

Now let's vertically center all of the elements inside their parent container which is .story__content . How are we gonna do that?
We could use css grid once more and it wouldn't be all to difficult to do that. However, it's just a one-dimensional layout. Because you have
that first heading then another one and ... , so all of the elements in there are all after another. BUT ON THE SIDES, YOU DON'T HAVE ANYTHING ELSE and
so it's just a one-dimensional layout, like it's going from top to bottom, so in this case the only direction is vertical. So we could use instead of
css grid, flexbox.
So how are we gonna do that?
First of all, we need to make .story__content which is the parent element of the elements that we want to center them inside their parent,
should be the flex container. So display: flex; on the &__content . Now all of the flex-items inside &__content are now SIDE BY SIDE(default behavior).
But that's not what we want.
Important: We want them one BELOW THE OTHER and so we need to change the flex-direction to column and with that, we also change
 the axis. So now the main axis is going from top to dawn and the cross axis is NOW going from left to right.
Now how do we now center all of those items across the main axis(which now is from top to bottom)?
We use justify-content: center;
Now when we change the size of viewport, you see that it always stays vertically centered.

Currently, we have a problem and that is that button is now ranging all the way from left to right(which currently(because of
flex-direction: column) is the direction of cross axis) and do you remember why that is happening?
It is, because the align-items prop(related to cross axis) in flexbox is set to stretch(be default), but we don't want that and we want to set it
to flex-start. In this case, using flex-start instead of stretch in align-items, doesn't really affect the other elements, just make the button not
ranging all the way from left to right and instead, the button will start from left(which is the starting point of cross axis currently) and go
until it's content requires, to the right.

Now let's center all of the elements inside of &__content with grid.
I commented some of props of &__content. Now which prop do we use to align all of our grid-tracks in vertical direction?
align-content prop.
Important: Now the same thing happens on button again, just like what we had before with flexbox, which is again the button now spans
 all the way across the last row grid track and that is, once more, because the grid-items by default, stretch all across their grid-cells.
So how do we stop them from doing that and instead put them to the start or in other words, to the left side?
Well, we're looking at the row axis(because that button is spanning across the row axis, currently.) and:
Important: to align the grid-items in row axis, we use justify-items.
So justify-items: start; and that should fix it.

So now we're using css grid for a one-dimensional layout and it's a bit counter-intuitive because for that, we have flexbox, but it's not
a problem at all and currently instead of 4 lines of css(flexbox solution), we have 3.

Currently, if you decrease the width of viewport, at some point there's not enough space there and we have too much space on the left and
right side and so we can also instead of having the padding hard-coded(the left and right paddings which are hard coded to being 12rem),
we can also set them as a percentage of the viewport(vw in this case(because we're decreasing the WIDTH of viewport and seeing that much space)).
So instead of 12rem, I used 8vw. Now if you resize the viewport's width, you see that now that padding changes as the width of viewport changes
and so that viewport width unit(vw) is getting more used for building truly responsive layouts.*/
/* 7. Building the Story Section - Part 2:
*/
/* My notes:
The first and last(outer) column and row tracks(lines) never would have gap and therefore they're always thin lines. But if you set some gap
for inner tracks(all of the tracks except the first and last are inner tracks or lines), they become thicker and are no more like lines but in the
explicit grid, they have height of 150px. */
